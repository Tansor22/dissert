%\includepdf[page=-,addtotoc={
%	1,chapter,1,Задание на выполнение ВКР,AppendixA
%}]{task.pdf}


\chapter{Исходный код} \label{app:B}

\section{Исходный код компонентов сервиса удаленного вызова команд}\label{app:B1}
\begin{lstlisting}[language=java]

import 'reflect-metadata';

import { bootstrapMicroframework } from 'microframework-w3tec';

import { banner } from './lib/banner';
import { Logger } from './lib/logger';
import { eventDispatchLoader } from './loaders/eventDispatchLoader';
import { expressLoader } from './loaders/expressLoader';
import { homeLoader } from './loaders/homeLoader';
import { iocLoader } from './loaders/iocLoader';
import { monitorLoader } from './loaders/monitorLoader';
import { publicLoader } from './loaders/publicLoader';
import { swaggerLoader } from './loaders/swaggerLoader';
import { typeormLoader } from './loaders/typeormLoader';
import { winstonLoader } from './loaders/winstonLoader';

/**
* EXPRESS TYPESCRIPT BOILERPLATE
* ----------------------------------------
*
* This is a boilerplate for Node.js Application written in TypeScript.
* The basic layer of this app is express. For further information visit
* the 'README.md' file.
*/
const log = new Logger(__filename);

bootstrapMicroframework({
	/**
	* Loader is a place where you can configure all your modules during microframework
	* bootstrap process. All loaders are executed one by one in a sequential order.
	*/
	loaders: [
	winstonLoader,
	iocLoader,
	eventDispatchLoader,
	typeormLoader,
	expressLoader,
	swaggerLoader,
	monitorLoader,
	homeLoader,
	publicLoader,
	],
})
.then(() => banner(log))
.catch(error => log.error('Application is crashed: ' + error));

import {
	Body, Delete, Get, JsonController, OnUndefined, Param, Post, Put
} from 'routing-controllers';

import { ProjectNotFoundError } from '../errors/ProjectNotFoundError';
import { Project } from '../models/Project';
import { ProjectService } from '../services/ProjectService';

@JsonController('/project')
export class ProjectController {
	
	constructor(
	private projectService: ProjectService
	) { }
	
	@Post()
	public create(@Body() project: Project): Promise<Project> {
		return this.projectService.create(project);
	}
	
	@Get()
	public readAll(): Promise<Project[]> {
		return this.projectService.readAll();
	}
	
	@OnUndefined(ProjectNotFoundError)
	@Get('/:uid')
	public read(@Param('uid') uid: string): Promise<Project> {
		return this.projectService.read(uid);
	}
	
	@OnUndefined(ProjectNotFoundError)
	@Put('/:uid')
	public update(@Param('uid') uid: string, @Body() project: Project): Promise<Project> {
		return this.projectService.update(uid, project);
	}
	
	@OnUndefined(ProjectNotFoundError)
	@Delete('/:uid')
	public delete(@Param('uid') uid: string): Promise<Project> {
		return this.projectService.delete(uid);
	}
}

import {
	Body, Delete, Get, JsonController, OnUndefined, Param, Post, Put, QueryParam
} from 'routing-controllers';

import { ScriptOrProjectNotFoundError } from '../errors/ScriptOrProjectNotFoundError';
import { Execution } from '../models/Execution';
import { Script } from '../models/Script';
import { ScriptService } from '../services/ScriptService';

@JsonController('/script')
export class ScriptController {
	
	constructor(
	private scriptService: ScriptService
	) { }
	
	@OnUndefined(ScriptOrProjectNotFoundError)
	@Post()
	public create(@Body() script: Script, @QueryParam('uid') uid: string): Promise<Script> {
		return this.scriptService.create(uid, script);
	}
	
	@OnUndefined(ScriptOrProjectNotFoundError)
	@Get()
	public readAll(@QueryParam('uid') uid: string): Promise<Script[]> {
		return this.scriptService.readAll(uid);
	}
	
	@OnUndefined(ScriptOrProjectNotFoundError)
	@Get('/byid/:id')
	public readById(@Param('id') id: number): Promise<Script> {
		return this.scriptService.readById(id);
	}
	
	@OnUndefined(ScriptOrProjectNotFoundError)
	@Get('/:name')
	public read(@QueryParam('uid') uid: string, @Param('name') name: string): Promise<Script> {
		return this.scriptService.read(uid, name);
	}
	
	@OnUndefined(ScriptOrProjectNotFoundError)
	@Put('/:name')
	public update(@QueryParam('uid') uid: string, @Param('name') name: string, @Body() script: Script): Promise<Script> {
		return this.scriptService.update(uid, name, script);
	}
	
	@OnUndefined(ScriptOrProjectNotFoundError)
	@Delete('/:name')
	public delete(@QueryParam('uid') uid: string, @Param('name') name: string): Promise<Script> {
		return this.scriptService.delete(uid, name);
	}
	
	@OnUndefined(ScriptOrProjectNotFoundError)
	@Get('/:name/executions')
	public readExecutions(@QueryParam('uid') uid: string, @Param('name') name: string): Promise<Execution> {
		return this.scriptService.readExecutions(uid, name);
	}
	
	@OnUndefined(ScriptOrProjectNotFoundError)
	@Post('/:name/execute')
	public execute(@QueryParam('uid') uid: string, @Param('name') name: string): Promise<Script> {
		return this.scriptService.execute(uid, name);
	}
}

import { Get, JsonController, OnUndefined, Param } from 'routing-controllers';

import { ScriptOrProjectNotFoundError } from '../errors/ScriptOrProjectNotFoundError';
import { Execution } from '../models/Execution';
import { ExecutionService } from '../services/ExecutionService';

@JsonController('/execution')
export class ScriptController {
	
	constructor(
	private executionService: ExecutionService
	) { }
	
	@OnUndefined(ScriptOrProjectNotFoundError)
	@Get('/:id')
	public read(@Param('id') id: number): Promise<Execution> {
		return this.executionService.read(id);
	}
}

import { Service } from 'typedi';
import { OrmRepository } from 'typeorm-typedi-extensions';

// TODO: accept logger and event dispatcher
// import { EventDispatcher, EventDispatcherInterface } from '../../decorators/EventDispatcher';
// import { Logger, LoggerInterface } from '../../decorators/Logger';
import { Execution } from '../models/Execution';
import { ExecutionRepository } from '../repositories/ExecutionRepository';

@Service()
export class ExecutionService {
	
	constructor(
	@OrmRepository() private executionRepository: ExecutionRepository
	// TODO: line 5
	// @EventDispatcher() private eventDispatcher: EventDispatcherInterface,
	// @Logger(__filename) private log: LoggerInterface
	) { }
	
	public read(id: number): Promise<Execution | undefined> {
		return this.executionRepository.findOne({ id });
	}
}

import { Service } from 'typedi';
import { OrmRepository } from 'typeorm-typedi-extensions';
import uuid from 'uuid';

// TODO: accept logger and event dispatcher
// import { EventDispatcher, EventDispatcherInterface } from '../../decorators/EventDispatcher';
// import { Logger, LoggerInterface } from '../../decorators/Logger';
import { Project } from '../models/Project';
import { ProjectRepository } from '../repositories/ProjectRepository';

@Service()
export class ProjectService {
	
	constructor(
	@OrmRepository() private projectRepository: ProjectRepository
	// TODO: line 5
	// @EventDispatcher() private eventDispatcher: EventDispatcherInterface,
	// @Logger(__filename) private log: LoggerInterface
	) { }
	
	public readAll(): Promise<Project[]> {
		return this.projectRepository.find({ relations: ['scripts'] });
	}
	
	public read(uid: string): Promise<Project | undefined> {
		return this.projectRepository.findOne({ uid });
	}
	
	public async create(project: Project): Promise<Project> {
		project.uid = uuid.v1();
		const newProject = await this.projectRepository.save(project);
		return newProject;
	}
	
	public update(uid: string, project: Project): Promise<Project> {
		project.uid = uid;
		return this.projectRepository.save(project);
	}
	
	public async delete(uid: string): Promise<any> {
		return this.projectRepository.delete(uid);
	}
	
}

import Client from 'node-ssh';
import { Service } from 'typedi';
import { OrmRepository } from 'typeorm-typedi-extensions';

import { env } from '../../env';
import { Execution } from '../models/Execution';
// TODO: accept logger and event dispatcher
// import { EventDispatcher, EventDispatcherInterface } from '../../decorators/EventDispatcher';
// import { Logger, LoggerInterface } from '../../decorators/Logger';
import { Script } from '../models/Script';
import { ExecutionRepository } from '../repositories/ExecutionRepository';
import { ProjectRepository } from '../repositories/ProjectRepository';
import { ScriptRepository } from '../repositories/ScriptRepository';

@Service()
export class ScriptService {
	
	constructor(
	@OrmRepository() private scriptRepository: ScriptRepository,
	@OrmRepository() private projectRepository: ProjectRepository,
	@OrmRepository() private executionRepository: ExecutionRepository
	// TODO: line 3
	// @EventDispatcher() private eventDispatcher: EventDispatcherInterface,
	// @Logger(__filename) private log: LoggerInterface
	) { }
	
	public async readAll(uid: string): Promise<Script[]> {
		const currentProject = await this.projectRepository.findOne({ uid });
		if (currentProject) {
			return this.scriptRepository.find({ where: { projectId: uid }, relations: ['executions'] });
		} else {
			return undefined;
		}
	}
	
	public async read(uid: string, name: string): Promise<Script | undefined> {
		const currentProject = await this.projectRepository.findOne({ uid });
		if (currentProject) {
			return this.scriptRepository.findOne({ where: { projectId: uid, name } });
		} else {
			return undefined;
		}
	}
	
	public async readById(id: number): Promise<Script | undefined> {
		return this.scriptRepository.findOne(id);
	}
	
	public async create(uid: string, script: Script): Promise<Script> {
		console.log(uid);
		script.id = undefined;
		script.projectId = uid;
		const newScript = await this.scriptRepository.save(script);
		return newScript;
	}
	
	public async update(uid: string, name: string, script: Script): Promise<Script> {
		const currentProject = await this.projectRepository.findOne({ uid });
		
		if (currentProject) {
			const updatingScript = await this.scriptRepository.findOne({ where: { name } });
			if (updatingScript) {
				script.id = updatingScript.id;
				script.projectId = updatingScript.projectId;
				return this.scriptRepository.save(script);
			} else {
				return undefined;
			}
		} else {
			return undefined;
		}
	}
	
	public async delete(uid: string, name: string): Promise<any> {
		const currentProject = await this.projectRepository.findOne({ uid });
		if (currentProject) {
			const deletingScript = await this.scriptRepository.findOne({ where: { projectId: uid, name } });
			if (deletingScript) {
				return this.scriptRepository.delete(deletingScript.id);
			} else {
				return undefined;
			}
		} else {
			return undefined;
		}
	}
	
	public async readExecutions(uid: string, name: string): Promise<any> {
		const currentProject = await this.projectRepository.findOne({ uid });
		if (!currentProject) { return undefined; }
		const currentScript = await this.scriptRepository.findOne({ where: { projectId: currentProject.uid, name } });
		if (!currentScript) { return undefined; }
		return this.executionRepository.find({ where: { scriptId: currentScript.id } });
	}
	
	public async execute(uid: string, name: string): Promise<any> {
		const currentProject = await this.projectRepository.findOne({ uid });
		if (!currentProject) { return undefined; }
		const currentScript = await this.scriptRepository.findOne({ where: { projectId: currentProject.uid, name } });
		if (!currentScript) { return undefined; }
		const ssh = new Client();
		const outsArray = [];
		const outsJsonb = {};
		await ssh.connect({
			host: currentProject.host,
			username: currentProject.user,
			privateKey: env.keys.private,
		});
		for (const key in currentScript.script) {
			if (!currentScript.script.hasOwnProperty(key)) { continue; }
			const result = await ssh.execCommand(currentScript.script[key], { cwd: currentProject.cwd });
			outsArray.push(result);
			outsJsonb[key] = result;
			if (result.stderr !== '') { break; }
		}
		await ssh.dispose();
		const execution = new Execution();
		execution.timestamp = new Date().toISOString();
		execution.outs = outsJsonb;
		execution.scriptId = currentScript.id;
		return this.executionRepository.save(execution);
	}
	
}
\end{lstlisting}

\section{Исходный код компонентов управляющего приложения архитектуры тестирования криптовалюных платежных шлюзов}\label{app:B2}
\begin{lstlisting}[language=java]
import { Body, Get, JsonController, OnUndefined, Post, QueryParam } from 'routing-controllers';
import { Validator } from 'routing-controllers/node_modules/class-validator';

import { Logger, LoggerInterface } from '../../../decorators/Logger';
import { MethodNotSupportedError } from '../../errors/MethodNotSupportedError';
import { ParamValidatingError } from '../../errors/ParamValidatingError';
import { BlockchainAccountService } from '../../services/BlockchainAccountService';

@JsonController('/accounts')
export class AddressController {
	
	public constraints: {
		[type: string]: string;
	};
	
	constructor(
	@Logger(__filename) private log: LoggerInterface,
	private blockchainAccountService: BlockchainAccountService,
	private validator: Validator
	) {
		this.constraints = {
			['id']: 'Must be alphanumeric string',
		};
		this.validator = new Validator();
	}
	
	@Post()
	@OnUndefined(MethodNotSupportedError)
	public createAccountOnBlockchain(@Body() body: any): any {
		this.log.info('Method: createAccountOnBlockchain, params:' + body);
		const validation = this.validator.isNotEmpty(body.id) && this.validator.isAlphanumeric(body.id);
		if (validation) {
			return this.blockchainAccountService.createAccountOnBlockchain(body);
		} else {
			this.log.error('Validation failed with ' + body + ' constraints: ' + this.constraints);
			throw new ParamValidatingError(body.blockchain, body.id, this.constraints);
		}
	}
	
	@Get()
	@OnUndefined(MethodNotSupportedError)
	public getAccountsOfBlockchain(@QueryParam('blockchain') blockchain: string): any {
		this.log.info('Method: getAccountsOfBlockchain, params:' + blockchain);
		return this.blockchainAccountService.getAccountsOfBlockchain(blockchain);
	}
	
	@Get('/info')
	@OnUndefined(MethodNotSupportedError)
	public getBlockchainAccountInfo(@QueryParam('blockchain') blockchain: string, @QueryParam('id') id: string): any {
		this.log.info('Method: getBlockchainAccountInfo, params:' + blockchain + ' ' + id);
		return this.blockchainAccountService.getBlockchainAccountInfo(blockchain, id);
	}
	
}


import {
	Body, Get, JsonController, OnUndefined, Post, QueryParam, QueryParams
} from 'routing-controllers';

import { Logger, LoggerInterface } from '../../../decorators/Logger';
import { MethodNotSupportedError } from '../../errors/MethodNotSupportedError';
import { BlockchainTransactionService } from '../../services/BlockchainTransactionService';

// @TODO: Validation for filter parameters
// import { Validator } from 'routing-controllers/node_modules/class-validator';
// import { ParamValidatingError } from '../../errors/ParamValidatingError';

@JsonController('/transaction')
export class TransactionController {
	
	public constraints: {
		[type: string]: string;
	};
	
	constructor(
	@Logger(__filename) private log: LoggerInterface,
	private blockchainTransactionService: BlockchainTransactionService
	// private validator: Validator
	) {
		this.constraints = {
			['id']: 'Must be alphanumeric string',
		};
		// this.validator = new Validator();
	}
	
	@Get()
	@OnUndefined(MethodNotSupportedError)
	public getTransaction(@QueryParam('blockchain') blockchain: string, @QueryParam('txhash') txhash: string): any {
		this.log.info('Method: getTransaction, params:' + blockchain + ' ' + txhash);
		return this.blockchainTransactionService.getTransaction(blockchain, txhash);
	}
	
	@Get('/txs')
	@OnUndefined(MethodNotSupportedError)
	public getTransactions(@QueryParams() filters: any): any {
		this.log.info('Method: getTransactions, params:' + filters);
		return this.blockchainTransactionService.getTransactions(filters);
	}
	
	@Post()
	@OnUndefined(MethodNotSupportedError)
	public createTransaction(@Body() body: any): any {
		this.log.info('Method: createTransaction, params:' + body);
		return this.blockchainTransactionService.createTransaction(body);
	}
}


import { Body, JsonController, Post } from 'routing-controllers';

import { Logger, LoggerInterface } from '../../../decorators/Logger';
import { BlockchainAccountService } from '../../services/BlockchainAccountService';

// @TODO: Validation for filter parameters
// import { Validator } from 'routing-controllers/node_modules/class-validator';
// import { ParamValidatingError } from '../../errors/ParamValidatingError';

@JsonController('/monitor')
export class WebhookController {
	
	public constraints: {
		[type: string]: string;
	};
	
	constructor(
	@Logger(__filename) private log: LoggerInterface,
	private blockchainAccountService: BlockchainAccountService
	// private validator: Validator
	) {
		this.constraints = {
			['id']: 'Must be alphanumeric string',
		};
		// this.validator = new Validator();
	}
	
	@Post()
	public setWebhook(@Body() body: any): any {
		this.log.info('Method: setWebhook, params:' + body);
		return this.blockchainAccountService.monitorAccount(body);
	}
}


export class AccountResponse {
	constructor(
	public address: string,
	public id: string,
	public balance: number,
	public blockchain: string
	) { }
	
	public stringify(): string {
		return `${this.blockchain} ${this.id} ${this.address} ${this.balance}`;
	}
}


export class RpcResultRetriever {
	constructor(
	public result: any
	) { }
}


export class TransactionListElementResponse {
	constructor(
	public blockchain: string,
	public account: string,
	public address: string,
	public hash: string,
	public category: 'send' | 'receive',
	public value: number,
	public confirmations: number,
	public block: number,
	public fee: number
	) { }
	
	public stringify(): string {
		return `${this.blockchain} ${this.account} ${this.address} ${this.hash} ${this.category} ${this.value} ${this.confirmations} ${this.block}`;
	}
}


export class TransactionResponse {
	constructor(
	public hash: string,
	public from: string,
	public to: string,
	public value: number,
	public blockchain: string,
	public confirmations: number,
	public block: number,
	public fee: number
	) { }
	
	public stringify(): string {
		return `${this.hash} ${this.from} ${this.to} ${this.value} ${this.blockchain} ${this.confirmations} ${this.block}`;
	}
}


import * as mongoose from 'mongoose';
import { Response } from 'request';
import * as rp from 'request-promise';
import { Body } from 'routing-controllers';
import { Service } from 'typedi';
import { OrmRepository } from 'typeorm-typedi-extensions';

import { Logger, LoggerInterface } from '../../decorators/Logger';
import { env } from '../../env';
import { AccountResponse } from '../controllers/responses/AccountResponse';
import {
	TransactionListElementResponse
} from '../controllers/responses/TransactionListElementResponse';
import { TransactionResponse } from '../controllers/responses/TransactionResponse';
import { AccountNotFound } from '../errors/AccountNotFound';
import { DatabusConsumeError } from '../errors/DatabusConsumeError';
import { SameAccountName } from '../errors/SameAccountName';
import { BitForkAccountRepository } from '../repositories/BitForkAccountRepository';
import { NodecallService } from './NodecallService';

@Service()
export class BitcoinService {
	
	constructor(
	@OrmRepository() private bitForkAccountRepository: BitForkAccountRepository,
	@Logger(__filename) private log: LoggerInterface,
	private nodeCallService: NodecallService,
	public options: rp.Options
	) {
		this.options = {
			uri : env.blockchains.bitcoin,
			method : 'POST',
			json: true,
		};
	}
	
	public async createAccount(id: string): Promise<any> {
		this.log.info('Creating account with name ' + id + ' on bitcoin blockchain');
		this.options.body = { method: 'getaddressesbyaccount', params: [id] };
		const addressesResponse = (await this.nodeCallService.makeRpcRequest(this.options))[0];
		if (addressesResponse === null || addressesResponse !== undefined && addressesResponse.error !== undefined) {
			this.log.error('Error for getting account' + id + ' addresses on bitcoin', [{method: 'createAccount'}]);
			if (addressesResponse.message !== undefined) {
				this.log.error(addressesResponse.message,  [{method: 'createAccount'}]);
			}
			throw new DatabusConsumeError('Service currently unavailable');
		}
		if (addressesResponse.length !== 0) {
			throw new SameAccountName(id);
		}
		this.options.body = { method: 'getnewaddress', params: [id] };
		const newAddressResponse = (await this.nodeCallService.makeRpcRequest(this.options))[0];
		if (newAddressResponse === null || newAddressResponse.error !== undefined) {
			this.log.error('Creating account' + id + ' on bitcoin was fault', [{method: 'createAccount'}]);
			if (newAddressResponse.message !== undefined) {
				this.log.error(newAddressResponse[0].message,  [{method: 'createAccount'}]);
			}
			throw new DatabusConsumeError('Service currently unavailable');
		} else {
			await this.bitForkAccountRepository.save({
				id: undefined,
				account: id,
				address: newAddressResponse,
				blockchain: 'bitcoin',
				time: Math.floor(Date.now() / 1000),
			});
		}
		return new AccountResponse(newAddressResponse, id, 0, 'bitcoin');
	}
	
	public async listAccounts(): Promise<any> {
		this.log.info('Getting all accounts of bitcoin blockchain node');
		this.options.body = { method: 'listaccounts', params: [] };
		const accounts = (await this.nodeCallService.makeRpcRequest(this.options))[0];
		if (accounts === null || accounts !== undefined && accounts.error !== undefined) {
			this.log.error('Error for listing account on bitcoin blockchain', [{method: 'listAccounts'}]);
			if (accounts.message !== undefined) {
				this.log.error(accounts.message,  [{method: 'listAccounts'}]);
			}
			throw new DatabusConsumeError('Service currently unavailable');
		}
		this.options.body = [];
		for (const id of Object.keys(accounts)) {
			this.options.body.push({ method: 'getaddressesbyaccount', params: [id] });
		}
		const accountAddresses = (await this.nodeCallService.makeRpcRequest(this.options));
		if (accountAddresses[0] === null || accountAddresses[0] !== undefined && accountAddresses[0].error !== undefined) {
			this.log.error('Error for getting address of accounts on bitcoin blockchain', [{method: 'listAccounts'}]);
			if (accountAddresses[0].message !== undefined) {
				this.log.error(accountAddresses[0].message,  [{method: 'listAccounts'}]);
			}
			throw new DatabusConsumeError('Service currently unavailable');
		}
		const response: AccountResponse[] = [];
		let accCounter = 0;
		for (const [key, value] of Object.entries(accounts)) {
			response.push(new AccountResponse(accountAddresses[accCounter++][0], key, value, 'bitcoin'));
		}
		return response;
	}
	
	public async accountInfo(id: string): Promise<any> {
		this.log.info('Getting given account info (' + id + ')');
		this.options.body = [];
		this.options.body.push({ method: 'getaddressesbyaccount', params: [id] });
		this.options.body.push({ method: 'getbalance', params: [id] });
		const batch = (await this.nodeCallService.makeRpcRequest(this.options));
		if (batch === null || batch !== undefined && batch.error !== undefined) {
			this.log.error('Error for getting account' + id + ' addresses on bitcoin', [{method: 'accountInfo'}]);
			if (batch.message !== undefined) {
				this.log.error(batch.message,  [{method: 'accountInfo'}]);
			}
			throw new DatabusConsumeError('Service currently unavailable');
		}
		if (batch[0].length === 0) {
			throw new AccountNotFound(id);
		}
		const account: AccountResponse = new AccountResponse(batch[0][0], id, batch[1], 'bitcoin');
		return account;
	}
	
	public async getInfo(): Promise<Response> {
		this.log.info('Bitcoin getinfo calling');
		this.options.body = { method: 'getinfo', params: [] };
		const response: Response = await rp(this.options);
		return response;
	}
	
	public async createTransaction(@Body() body: any): Promise<any> {
		this.log.info('Bitcoin transaction creating');
		this.options.body = { method: 'getaddressesbyaccount', params: [body.from] };
		const addressesResponse = (await this.nodeCallService.makeRpcRequest(this.options))[0];
		if (addressesResponse === null || addressesResponse !== undefined && addressesResponse.error !== undefined) {
			this.log.error('Error for getting account' + body.from + ' addresses on bitcoin', [{method: 'createTransaction'}]);
			if (addressesResponse.message !== undefined) {
				this.log.error(addressesResponse.message,  [{method: 'createTransaction'}]);
			}
			throw new DatabusConsumeError('Service currently unavailable');
		}
		if (addressesResponse.length === 0) {
			throw new AccountNotFound(body.from);
		}
		this.options.body = { method: 'sendfrom', params: [body.from, body.to, body.value] };
		const txResponse = (await this.nodeCallService.makeRpcRequest(this.options))[0];
		if (txResponse.error !== undefined) {
			if (txResponse.error.error !== undefined && txResponse.error.error.message !== undefined) {
				this.log.error(txResponse.error.error.message, [{method: 'createTransaction'}]);
				throw new DatabusConsumeError(txResponse.error.error.message);
			} else {
				this.log.error(txResponse.message, [{method: 'createTransaction'}]);
				throw new DatabusConsumeError('Service currently unavailable');
			}
		}
		return txResponse;
	}
	
	public async getTransaction(txhash: string): Promise<any> {
		this.log.info('Bitcoin transaction getting by hash: ' + txhash);
		this.options.body = { method: 'gettransaction', params: [txhash] };
		const transaction = (await this.nodeCallService.makeRpcRequest(this.options))[0];
		if (transaction.error !== undefined) {
			if (transaction.error.error !== undefined && transaction.error.error.message !== undefined) {
				this.log.error(transaction.error.error.message, [{method: 'getTransaction'}]);
				throw new DatabusConsumeError(transaction.error.error.message);
			} else {
				this.log.error(transaction.message, [{method: 'getTransaction'}]);
				throw new DatabusConsumeError('Service currently unavailable');
			}
		}
		let receive = 'notstated';
		let sender = 'notstated';
		let amount = transaction.amount;
		for (const entry of transaction.details) {
			if (entry.category === 'receive') {
				if (amount === 0) {
					amount = entry.amount;
				}
			} else if (entry.category === 'send') {
				receive = entry.address;
				sender = entry.account;
			}
		}
		this.options.body = { method: 'getblock', params: [transaction.blockhash] };
		let block;
		if (transaction.blockhash !== undefined) {
			block = (await this.nodeCallService.makeRpcRequest(this.options))[0];
			if (block === null || block !== undefined && block.error !== undefined) {
				this.log.error('Error when getting block in bitcoin', [{method: 'getTransaction'}]);
				if (block.message !== undefined) {
					this.log.error(block.message,  [{method: 'getTransaction'}]);
				}
				throw new DatabusConsumeError('Service currently unavailable');
			}
		} else {
			block = { height: 'not confirmed' };
		}
		const response: TransactionResponse = new TransactionResponse(
		txhash,
		sender,
		receive,
		amount,
		'bitcoin',
		transaction.confirmations,
		block.height,
		transaction.fee
		);
		return response;
	}
	
	/*
	* Available filters
	*
	* address: string
	* afterTimestamp: number
	* fromValue: number
	* toValue: number
	*/
	// @TODO: transaction list by filter
	// @TODO: use array.filter() standard method
	public async getTransactions(filters: any): Promise<any> {
		let accountId = '*';
		let address: string = undefined;
		let fromValue = 0;
		let toValue = 99999999;
		let afterTimestamp = 0;
		let beforeTimestamp = 9999999999;
		let addressResponse;
		let accountResponse;
		if (filters.accountId !== undefined && filters.address === undefined) {
			accountId = filters.accountId;
			this.options.body = { method: 'getaddressesbyaccount', params: [accountId] };
			addressResponse = (await this.nodeCallService.makeRpcRequest(this.options))[0];
			if (addressResponse === null || addressResponse !== undefined && addressResponse.error !== undefined) {
				this.log.error('Error for getting account' + accountId + ' addresses on bitcoin', [{method: 'getTransactions'}]);
				if (addressResponse.message !== undefined) {
					this.log.error(addressResponse.message,  [{method: 'getTransactions'}]);
				}
				throw new DatabusConsumeError('Service currently unavailable');
			}
			address = addressResponse[0];
		}
		if (filters.accountId === undefined && filters.address !== undefined) {
			address = filters.address;
			this.options.body = { method: 'getaccount', params: [address] };
			accountResponse = (await this.nodeCallService.makeRpcRequest(this.options))[0];
			if (accountResponse === null || accountResponse.error !== undefined) {
				this.log.error('Error for getting account id of address ' + address + ' on bitcoin blockchain', [{method: 'getTransactions'}]);
				if (accountResponse.message !== undefined) {
					this.log.error(accountResponse.message,  [{method: 'getTransactions'}]);
				}
				throw new DatabusConsumeError('Service currently unavailable');
			}
			accountId = accountResponse;
		}
		if (filters.accountId !== undefined && filters.address !== undefined) {
			accountId  = filters.accountId;
			this.options.body = { method: 'getaddressesbyaccount', params: [accountId] };
			addressResponse = (await this.nodeCallService.makeRpcRequest(this.options))[0];
			if (addressResponse === null || addressResponse !== undefined && addressResponse.error !== undefined) {
				this.log.error('Error for getting account' + accountId + ' addresses on bitcoin', [{method: 'getTransactions'}]);
				if (addressResponse.message !== undefined) {
					this.log.error(addressResponse.message,  [{method: 'getTransactions'}]);
				}
				throw new DatabusConsumeError('Service currently unavailable');
			}
			address = addressResponse[0];
			if (address !== filters.address) {
				return [];
			}
		}
		if (filters.fromValue !== undefined) {
			fromValue = (filters.fromValue as number);
		}
		if (filters.toValue !== undefined) {
			toValue = (filters.toValue as number);
		}
		if (filters.afterTimestamp !== undefined) {
			afterTimestamp = filters.afterTimestamp.length > 10 ? (filters.afterTimestamp.slice(0, 10) as number) : (filters.afterTimestamp as number);
		}
		if (filters.beforeTimestamp !== undefined) {
			beforeTimestamp = filters.beforeTimestamp.length > 10 ? (filters.beforeTimestamp.slice(0, 10) as number) : (filters.beforeTimestamp as number);
		}
		this.options.body = { method: 'listtransactions', params: [accountId, 99999999] };
		const transactionsFromNode = (await this.nodeCallService.makeRpcRequest(this.options))[0];
		if (transactionsFromNode === null || transactionsFromNode !== undefined && transactionsFromNode.error !== undefined) {
			this.log.error('Error for listtransactions on bitcoin', [{method: 'getTransactions'}]);
			if (transactionsFromNode.message !== undefined) {
				this.log.error(transactionsFromNode.message,  [{method: 'getTransactions'}]);
			}
			throw new DatabusConsumeError('Service currently unavailable');
		}
		const transactionFiltered: TransactionListElementResponse[] = [];
		this.options.body = { method: 'getblockcount', params: [] };
		const currentBlock = (await this.nodeCallService.makeRpcRequest(this.options))[0];
		if (currentBlock === null || currentBlock !== undefined && currentBlock.error !== undefined) {
			this.log.error('Error when getting block in bitcoin', [{method: 'getTransactions'}]);
			if (currentBlock.message !== undefined) {
				this.log.error(currentBlock.message,  [{method: 'getTransactions'}]);
			}
			throw new DatabusConsumeError('Service currently unavailable');
		}
		let transactionsBlock: number;
		for (const transaction of transactionsFromNode) {
			if (
			(
			transaction.account === accountId || accountId === '*'
			) &&
			(
			transaction.category === 'send' || transaction.category === 'receive'
			) &&
			(
			transaction.time >= afterTimestamp
			) &&
			(
			transaction.time <= beforeTimestamp
			) &&
			(
			Math.abs(transaction.amount) >= fromValue
			) &&
			(
			Math.abs(transaction.amount) <= toValue
			)
			) {
				if (transaction.confirmations === 0) {
					transactionsBlock = 0;
				} else {
					transactionsBlock = currentBlock - (transaction.confirmations - 1);
				}
				if (address === undefined) {
					address = transaction.address;
				}
				transactionFiltered.push(new TransactionListElementResponse(
				'bitcoin',
				transaction.account,
				address,
				transaction.txid,
				transaction.category,
				Math.abs(transaction.amount),
				transaction.confirmations,
				transactionsBlock,
				transaction.fee
				));
			}
		}
		return transactionFiltered;
	}
	
	// Currently unused, but ready for working.
	public async findInMempool(accountId: string): Promise<any> {
		this.options.body = { method: 'getaddressesbyaccount', params: [accountId] };
		let address = (await this.nodeCallService.makeRpcRequest(this.options))[0];
		if (address === null || address.error !== undefined) {
			this.log.error('Error for getting account' + accountId + ' addresses on bitcoin', [{method: 'getTransactions'}]);
			if (address.message !== undefined) {
				this.log.error(address.message,  [{method: 'getTransactions'}]);
			}
			throw new DatabusConsumeError('Service currently unavailable');
		}
		address = address[0];
		if (address === undefined || address === '' || address === null) {
			return [];
		}
		
		const mongodConnection = (global as any).frameworkSettings.getData('bitcoin_mongo_connection') as mongoose.Connection;
		const mempool = mongodConnection.db.collection('transactions');
		const receivingRawTxs = await mempool.find({
			'vout.scriptPubKey.addresses': {
				$in: [ address ],
			},
		}).toArray();
		const result: TransactionListElementResponse[] = [];
		for (const txs of receivingRawTxs) {
			let potentialVout = undefined;
			for (const vout of txs.vout) {
				if (vout.scriptPubKey.addresses[0] === address) {
					potentialVout = vout;
					break;
				}
			}
			if (potentialVout !== undefined) {
				result.push(new TransactionListElementResponse(
				'bitcoin',
				accountId,
				address,
				txs.txid,
				'receive',
				Math.abs(potentialVout.value),
				0,
				0,
				txs.fee
				));
			}
		}
		return result;
	}
	
}


import * as rp from 'request-promise';
import { Body } from 'routing-controllers';
import { Service } from 'typedi';
import { OrmRepository } from 'typeorm-typedi-extensions';
import * as _ from 'underscore';
import * as Web3 from 'web3';

import { Logger, LoggerInterface } from '../../decorators/Logger';
import { env } from '../../env';
import { AccountResponse } from '../controllers/responses/AccountResponse';
import {
	TransactionListElementResponse
} from '../controllers/responses/TransactionListElementResponse';
import { TransactionResponse } from '../controllers/responses/TransactionResponse';
import { AccountNotFound } from '../errors/AccountNotFound';
import { DatabusConsumeError } from '../errors/DatabusConsumeError';
import { InsufficientBalance } from '../errors/InsufficientBalance';
import { SameAccountName } from '../errors/SameAccountName';
import { TransactionNotFound } from '../errors/TransactionNotFound';
import { EthereumAccountRepository } from '../repositories/EthereumAccountRepository';
import { EthereumTransactionRepository } from '../repositories/EthereumTransactionRepository';
import { NodecallService } from './NodecallService';

@Service()
export class EthereumService {
	
	constructor(
	@OrmRepository() private ethereumAccountRepository: EthereumAccountRepository,
	@OrmRepository() private ethereumTransactionRepository: EthereumTransactionRepository,
	@Logger(__filename) private log: LoggerInterface,
	private nodeCallService: NodecallService,
	private options: rp.Options,
	private web3: Web3
	) {
		this.web3 = new Web3(new Web3.providers.HttpProvider(env.blockchains.ethereum));
		this.options = {
			uri : env.blockchains.ethereum,
			method : 'POST',
			json: true,
		};
	}
	
	public async createAccount(id: string): Promise<any> {
		this.log.info('Creating account with name ' + id + ' on ethereum blockchain');
		const tryAccount = await this.ethereumAccountRepository.findOne({
			where: {
				name: id,
			},
		});
		if (tryAccount !== undefined) {
			throw new SameAccountName(id);
		}
		/*
		* Just a way to password generation.
		* We take given name, concatenate it with current timestamp and number of existing accounts
		* Then we are using just a Fisher-Yates shuffle algorithm from underscore.js library.
		* If our password's length is more than 12 we just slice it to 12.
		*/
		const currentTimestampValue = + new Date();
		const numberOfAccounts = await this.ethereumAccountRepository.count();
		const passwordSaltString = id + currentTimestampValue.toString() + numberOfAccounts;
		let completedPassword = (_.shuffle(passwordSaltString.split(''))).join('');
		completedPassword = completedPassword.length > 12 ? completedPassword.slice(0, 13) : completedPassword;
		this.options.body = { method: 'personal_newAccount', params: [completedPassword], id: '777' };
		
		const createAccRes = await this.nodeCallService.makeRpcRequest(this.options);
		const response = createAccRes[0];
		if (response === null || response.error !== undefined) {
			this.log.error('Creating account' + id + ' on ethereum was fault', [{method: 'createAccount'}]);
			if (response !== null && response.message !== undefined ) {
				this.log.error(response.message,  [{method: 'createAccount'}]);
			}
			throw new DatabusConsumeError('Service currently unavailable');
		}
		await this.ethereumAccountRepository.save({id: undefined, name: id, address: response, password: completedPassword});
		const account = new AccountResponse(response, id, 0, 'ethereum');
		return account;
	}
	
	public async listAccounts(): Promise<any> {
		this.log.info('Getting all accounts of ethereum blockchain node');
		const accounts = await this.ethereumAccountRepository.find();
		const response: AccountResponse[] = [];
		
		this.options.body = [];
		for (const account of accounts) {
			this.options.body.push({ method: 'eth_getBalance', params: [account.address, 'latest'], id: '777' });
		}
		const balanceResponses = await this.nodeCallService.makeRpcRequest(this.options);
		if (balanceResponses[0] === null || balanceResponses.length !== 0 && balanceResponses[0].error !== undefined) {
			this.log.error('Error for getting account balances on ethereum was fault', [{method: 'listAccounts'}]);
			if (balanceResponses[0] !== null && balanceResponses[0].message !== undefined) {
				this.log.error(balanceResponses[0].message,  [{method: 'listAccounts'}]);
			}
			throw new DatabusConsumeError('Service currently unavailable');
		}
		
		let accountCounter = 0;
		for (const account of accounts) {
			const accountBalance = parseInt(balanceResponses[accountCounter++], 16);
			response.push(new AccountResponse(account.address, account.name, parseFloat(this.web3.fromWei(accountBalance, 'ether').toString()), 'ethereum'));
		}
		return response;
	}
	
	public async accountInfo(id: string): Promise<any> {
		this.log.info('Getting given ethereum account info (' + id + ')');
		const account = await this.ethereumAccountRepository.findOne({
			where: {
				name: id,
			},
		});
		if (account === undefined) {
			this.log.error('Cannot find account with name ' + id + ' (ethereum)', [{method: 'accountInfo'}]);
			throw new AccountNotFound(id);
		}
		this.options.body = { method: 'eth_getBalance', params: [account.address, 'latest'], id: '777' };
		
		const balanceResponse = await this.nodeCallService.makeRpcRequest(this.options);
		if (balanceResponse[0] === null || balanceResponse[0].error !== undefined) {
			this.log.error(
			'Error for getting balance of ' + account.name  + ':' + account.address + ' on ethereum',
			[{method: 'accountInfo'}]
			);
			if (balanceResponse[0] !== null && balanceResponse[0].message !== undefined) {
				this.log.error(balanceResponse[0].message,  [{method: 'accountInfo'}]);
			}
			throw new DatabusConsumeError('Service currently unavailable');
		}
		
		const accountBalance = parseInt(balanceResponse[0], 16);
		return new AccountResponse(account.address, account.name, parseFloat(this.web3.fromWei(accountBalance, 'ether').toString()), 'ethereum' );
	}
	
	public async createTransaction(@Body() body: any): Promise<any> {
		this.log.info('Ethereum transaction creating');
		
		const account = await this.ethereumAccountRepository.findOne({
			where: {
				name: body.from,
			},
		});
		if (account === undefined) {
			throw new AccountNotFound(body.from);
		}
		this.options.body = [];
		this.options.body.push({ method: 'eth_getBalance', params: [account.address, 'latest'], id: '777' });
		this.options.body.push({ method: 'eth_gasPrice', params: [], id: '777' });
		const promises = await this.nodeCallService.makeRpcRequest(this.options);
		if (promises[0] === null || promises[0].error !== undefined) {
			this.log.error(
			'Error for getting balance of ' + account.name  + ':' + account.address + ' on ethereum blockchain',
			[{method: 'createTransaction'}]
			);
			if (promises[0] !== null && promises[0].message !== undefined) {
				this.log.error(promises[0].message,  [{method: 'createTransaction'}]);
			}
			throw new DatabusConsumeError('Service currently unavailable');
		}
		if (promises[1] === null || promises[1].error !== undefined) {
			this.log.error(
			'Error for getting gasPrice on ethereum blockchain',
			[{method: 'createTransaction'}]
			);
			if (promises[1] !== null && promises[1].message !== undefined) {
				this.log.error(promises[1].message,  [{method: 'createTransaction'}]);
			}
			throw new DatabusConsumeError('Service currently unavailable');
		}
		
		const gasUsed = this.web3.eth.estimateGas({ from: account.address, to: body.to, value: this.web3.toWei(body.value, 'ether') });
		const gasPrice = parseInt(promises[1], 16);
		const weiValue = this.web3.toWei(body.value, 'ether');
		this.log.info('fee: ', gasUsed, gasPrice, weiValue);
		// Checking if account got enough coins for that tx
		const requiredBalance = gasUsed * gasPrice + parseFloat(weiValue);
		
		const accountBalance = parseInt(promises[0], 16);
		if (accountBalance < requiredBalance) {
			this.log.warn('Insufficient balance: ' + accountBalance + ', but need ' + requiredBalance);
			throw new InsufficientBalance(parseFloat(this.web3.fromWei(accountBalance, 'ether').toString()), account.name);
		}
		// eth_sendTransaction needs two commands: personal_unlockAccount and eth_sendTransaction. It must be executed one by one in a sequential order
		// We will use batch feature of JSON-RPC 2.0 (array of commands in body)
		if (account.address !== undefined) {
			this.options.body = [];
			this.options.body. push ({
				method: 'personal_unlockAccount',
				params: [account.address, account.password, 120],
				id: '777',
			});
		}
		// Storing first command (unlock account)
		this.options.body.push({
			method: 'eth_sendTransaction',
			params: [{ from: account.address, to: body.to, value: this.web3.toHex(weiValue), gas: this.web3.toHex(gasUsed)}],
			id: '777',
		});
		const returnedPromises = await this.nodeCallService.makeRpcRequest(this.options);
		if (returnedPromises[0] === null || returnedPromises[0] === false || returnedPromises[0].error !== undefined) {
			this.log.error('Unlocking ' + body.from + ' account result FALSE on ethereum', [{method: 'createTransaction'}]);
			if (returnedPromises[0] !== null && returnedPromises[0].message !== undefined) {
				this.log.error(returnedPromises[0].message,  [{method: 'createTransaction'}]);
			}
			throw new DatabusConsumeError('Service currently unavailable');
		} else if (returnedPromises[1] === null || returnedPromises[1].error !== undefined) {
			this.log.error('TX sending was fault on ethereum', [{method: 'createTransaction'}]);
			if (returnedPromises[1] !== null && returnedPromises[1].message !== undefined) {
				this.log.error(returnedPromises[1].message,  [{method: 'createTransaction'}]);
			}
			throw new DatabusConsumeError('Service currently unavailable');
		}
		this.log.info('Unlocking ' + body.from + ' account result: ' + returnedPromises[0]);
		this.log.info('TX hash:' + returnedPromises[0]);
		const txSendRes = returnedPromises[1];
		return txSendRes;
	}
	
	public async getTransaction(txhash: string): Promise<any> {
		this.log.info('Ethereum transaction getting by hash: ' + txhash);
		// We will use batch feature of JSON-RPC 2.0 (array of commands in body)
		this.options.body = [];
		this.options.body.push({ method: 'eth_getTransactionByHash', params: [txhash], id: '777'  });
		this.options.body.push({ method: 'eth_blockNumber', params: [], id: '777'  });
		const responses = await this.nodeCallService.makeRpcRequest(this.options);
		if (responses[1] === null || responses[1].error !== undefined) {
			this.log.error('Error when getting ethereum block number', [{method: 'getTransaction'}]);
			if (responses[1] !== null && responses[1].message !== undefined) {
				this.log.error(responses[1].message,  [{method: 'getTransaction'}]);
			}
			throw new DatabusConsumeError('Service currently unavailable');
		} else if (responses[0] === null || responses[0].error !== undefined) {
			this.log.error('Transaction with hash ' + txhash + ' not found on ethereum', [{method: 'getTransaction'}]);
			if (responses[0] !== null && responses[0].message !== undefined) {
				this.log.error(responses[0].message,  [{method: 'getTransaction'}]);
			}
			throw new TransactionNotFound(txhash);
		}
		const transaction = responses[0];
		
		const response: TransactionResponse = new TransactionResponse(
		transaction.hash,
		transaction.from,
		transaction.to,
		parseFloat(this.web3.fromWei(parseInt(transaction.value, 16), 'ether')),
		'ethereum',
		parseInt(responses[1], 16) - parseInt(transaction.blockNumber, 16),
		parseInt(transaction.blockNumber, 16),
		parseFloat(this.web3.fromWei(transaction.gas * transaction.gasPrice, 'ether').toString())
		);
		
		return response;
	}
	
	/*
	* Available filters
	*
	* accountId
	* address: string
	* afterTimestamp: number - Фильтр на транзакции после данного таймштампа
	* beforeTimestamp: number - Фильтр на транзакции до данного таймштампа
	* fromValue: number - Начиная с какой суммы
	* toValue: number - Максимальное значение суммы включительно
	*/
	// @TODO: transaction list by filter
	// @TODO: use array.filter() standard method
	public async getTransactions(filters: any): Promise<any> {
		this.log.info('get transaction by filters from ethereum blockchain');
		// Current block number
		this.options.body = { method: 'eth_blockNumber', params: [], id: '777'  };
		const currentBlockResponse = await this.nodeCallService.makeRpcRequest(this.options);
		if (currentBlockResponse[0] === null || currentBlockResponse[0].error !== undefined) {
			this.log.error('Error when getting block number', [{method: 'getTransactions'}]);
			if (currentBlockResponse[0] !== null && currentBlockResponse[0].message !== undefined) {
				this.log.error(currentBlockResponse[0].message,  [{method: 'getTransactions'}]);
			}
			throw new DatabusConsumeError('Service currently unavailable');
		}
		const currentBlock = parseInt(currentBlockResponse[0], 16);
		
		const response: TransactionListElementResponse[] = [];
		
		const queryBuilderForSendTxs = await this.ethereumTransactionRepository.createQueryBuilder('ethereum_transaction');
		const queryBuilderForReceivedTxs = await this.ethereumTransactionRepository.createQueryBuilder('ethereum_transaction');
		
		let address = undefined; // адрес аккаунта, связанный с транзакциями. Будет определен ниже, если искали по accountId
		if (filters.accountId !== undefined) {
			const account = await this.ethereumAccountRepository.findOne({
				where: {
					name: filters.accountId,
				},
			});
			if (account === undefined) {
				this.log.error('Cannot find account with name ' + filters.accountId + ' (ethereum)', [{method: 'getTransactions'}]);
				throw new AccountNotFound(filters.accountId);
			}
			
			address = account.address;
			this.buildQueryWithWhere(queryBuilderForSendTxs, 'from', '=', 'fromField', address);
			this.buildQueryWithWhere(queryBuilderForReceivedTxs, 'to', '=', 'toField', address);
		}
		if (filters.address !== undefined) {
			// если искали по accountId и адрес этого аккаунта не совпадает с адресом из фильтра
			if (filters.accountId !== undefined && address !== filters.address) {
				return [];
			}
			this.buildQueryWithWhere(queryBuilderForSendTxs, 'from', '=', 'fromField', filters.address);
			this.buildQueryWithWhere(queryBuilderForReceivedTxs, 'to', '=', 'toField', filters.address);
		}
		if (filters.afterTimestamp !== undefined) {
			this.buildQueryWithWhere(queryBuilderForSendTxs, 'timestamp', '>=', 'timestampField', filters.afterTimestamp as number);
			this.buildQueryWithWhere(queryBuilderForReceivedTxs, 'timestamp', '>=', 'timestampField', filters.afterTimestamp as number);
		}
		if (filters.beforeTimestamp !== undefined) {
			this.buildQueryWithWhere(queryBuilderForSendTxs, 'timestamp', '<=', 'beforeTimestampField', filters.beforeTimestamp as number);
			this.buildQueryWithWhere(queryBuilderForReceivedTxs, 'timestamp', '<=', 'beforeTimestampField', filters.beforeTimestamp as number);
		}
		if (filters.fromValue !== undefined) {
			this.buildQueryWithWhere(queryBuilderForSendTxs, 'value', '>=', 'fromValueField', filters.fromValue as number);
			this.buildQueryWithWhere(queryBuilderForReceivedTxs, 'value', '>=', 'fromValueField', filters.fromValue as number);
		}
		if (filters.toValue !== undefined) {
			this.buildQueryWithWhere(queryBuilderForSendTxs, 'value', '<=', 'toValueField', filters.toValue as number);
			this.buildQueryWithWhere(queryBuilderForReceivedTxs, 'value', '<=', 'toValueField', filters.toValue as number);
		}
		
		const sendTxsResponse = await queryBuilderForSendTxs.getMany();
		const receivedTxsResponse = await queryBuilderForReceivedTxs.getMany();
		
		const accounts = await this.ethereumAccountRepository.find();
		let associatedWithTxAccount;
		
		for (const sendTx of sendTxsResponse) {
			for (const acc of accounts) {
				if (acc.address === sendTx.from) {
					associatedWithTxAccount = acc.name;
					break;
				}
			}
			
			response.push( new TransactionListElementResponse(
			'ethereum',
			associatedWithTxAccount,
			sendTx.from,
			sendTx.hash,
			'send',
			sendTx.value,
			currentBlock - sendTx.block,
			sendTx.block,
			sendTx.fee
			));
		}
		
		for (const receivedTx of receivedTxsResponse) {
			for (const acc of accounts) {
				if (acc.address === receivedTx.to) {
					associatedWithTxAccount = acc.name;
					break;
				}
			}
			
			response.push( new TransactionListElementResponse(
			'ethereum',
			associatedWithTxAccount,
			receivedTx.to,
			receivedTx.hash,
			'receive',
			receivedTx.value,
			currentBlock - receivedTx.block,
			receivedTx.block,
			receivedTx.fee
			));
		}
		return response;
	}
	
	private async buildQueryWithWhere(someQueryBuilder: any, field: string, operation: string, aliasKey: string, fieldValue: any): Promise<any> {
		const aliasObj = {};
		aliasObj[aliasKey] = fieldValue;
		
		if  (someQueryBuilder.expressionMap.wheres[0] === undefined) {
			someQueryBuilder.where('ethereum_transaction.' + field + operation + ':' + aliasKey, aliasObj);
		} else {
			someQueryBuilder.andWhere('ethereum_transaction.' + field + operation + ':' + aliasKey, aliasObj);
		}
	}
}


import { Connection } from 'amqplib';
import { MicroframeworkSettings } from 'microframework-w3tec';
import { Options } from 'request';
import { Service } from 'typedi';

import { Logger, LoggerInterface } from '../../decorators/Logger';

@Service()
export class NodecallService {
	
	constructor(
	@Logger(__filename) private log: LoggerInterface
	) { }
	
	public async makeRpcRequest(options: Options): Promise<any> {
		const settings = (global as any).frameworkSettings as MicroframeworkSettings;
		const amqpConnection: Connection = settings.getData('mq_connection');
		const channel = await amqpConnection.createChannel();
		// We need to set up some random correlationId for detecting requests from concrete users
		const correlation = Math.random().toString() + Math.random().toString() + Math.random().toString();
		const rpcResponse = await new Promise ((resolve, reject) => {
			channel.assertQueue('', {exclusive: true, autoDelete: true}).then(replyQueue => {
				channel.sendToQueue('rpc_queue', Buffer.from(JSON.stringify(options)), { correlationId: correlation, replyTo: replyQueue.queue });
				channel.consume(replyQueue.queue, async (msg) => {
					if (msg.properties.correlationId === correlation) {
						const responseFromdatabus = JSON.parse(msg.content.toString());
						resolve(responseFromdatabus);
					}
				}, {noAck: true})
				.catch((consumeError) => {
					this.log.error('Consuming from reply queue error!', consumeError);
					setTimeout(() => { channel.close(); }, 7000);
					throw new Error('Service currently unavailable');
				});
			}).catch((assertQueueError) => {
				this.log.error('Error in reply queue asserting!', assertQueueError);
				setTimeout(() => { channel.close(); }, 7000);
				throw new Error('Service currently unavailable');
			});
		}) as any[];
		setTimeout(() => { channel.close(); }, 7000);
		return rpcResponse;
	}
	
}


#!/usr/bin/env node
require('dotenv').config()
const amqp = require('amqplib/callback_api')
const rp = require('request-promise')
const winston = require('winston')

const logger = winston.createLogger({
	level: 'info',
	format: winston.format.json(),
	transports: [
	new winston.transports.Console()
	]
})

if (process.env.NODE_ENV !== 'production') {
	logger.transports[0].format = winston.format.simple()
}

amqp.connect(process.env.RABBIT_STRING, function (error, connection) {
	if (error) {
		logger.error(error)
		throw error
	}
	connection.createChannel(function (error, channel) {
		if (error) {
			logger.error(error)
			throw error
		}
		const databusQueueName = 'rpc_queue'
		channel.assertQueue(databusQueueName, {durable: false})
		channel.prefetch(1)
		logger.info('DatabusWorker is ready!')
		channel.consume(databusQueueName, async function reply (msg) {
			const parsedMessage = JSON.parse(msg.content.toString())
			logger.info('Fetched ' + msg.content)
			let successRequest = true
			let rpcResponses = await rp(parsedMessage).catch((e) => {
				successRequest = false
				channel.sendToQueue(msg.properties.replyTo, Buffer.from(JSON.stringify([e])), {correlationId: msg.properties.correlationId})
				channel.ack(msg)
			})
			if (successRequest) {
				if (!Array.isArray(rpcResponses)) {
					rpcResponses = [rpcResponses]
				}
				const ourResponses = []
				for (const response of rpcResponses) {
					logger.info('Response from RPC ' + JSON.stringify(response))
					if (response.result !== undefined) {
						ourResponses.push(response.result)
					} else {
						ourResponses.push(response)
					}
				}
				channel.sendToQueue(msg.properties.replyTo, Buffer.from(JSON.stringify(ourResponses)), {correlationId: msg.properties.correlationId})
				channel.ack(msg)
			}
		})
	})
})
\end{lstlisting}


\section{Полный исходный код модели для верификации}\label{app:B3}
\begin{lstlisting}[language=Promela]

#define P 5

chan SGX=[0] of {short}; //канал для генерации случайного числа

mtype  = {STATE_INIT, STATE_GEN, STATE_WAITING, STATE_MINEBLOCK, STATE_NOMINEBLOCK};
mtype state = STATE_INIT; //глобальное состояние сети
mtype procStates[P]; //состояния узлов сети

short procTimes[P]; //время ожидания узлов

bool isGenerating = false;
byte generator;  //процесс-генератор последнего блока

short Nblock = 0; //количество блоков


ltl willBeGenerated { <> (Nblock > 0) };

ltl checkFor0 { [] (isGenerating && (generator == 0) ->  procTimes[0] <= procTimes[1] && procTimes[0] <= procTimes[2] && procTimes[0] <= procTimes[3] && procTimes[0] <= procTimes[4] 
&& procStates[0]==STATE_MINEBLOCK && procStates[1]==STATE_NOMINEBLOCK && procStates[2]==STATE_NOMINEBLOCK && procStates[3]==STATE_NOMINEBLOCK && procStates[4]==STATE_NOMINEBLOCK)
};




active proctype processor() {  
byte buf;
short nr;	
do
:: {
SGX ? buf;
do
:: (nr < 32768) -> nr++;
:: (nr > 0) -> nr--;		
:: break
od;
SGX ! nr;
}
od
}


proctype proc(byte N) {
do
:: {
//ждем следующего цикла - состояния STATE_INIT
do  
:: (state == STATE_INIT) -> break;
:: else -> skip;
od

procStates[N] = STATE_GEN;
//сгенерировать случайное число - запросить у процессора 
short nr = 0;
SGX ! 1;
SGX ? nr;
procTimes[N] = nr;
printf("Process pid = %d  got nr = %d \n", _pid, nr);
procStates[N] = STATE_WAITING;

//эмулировать ожидание - в цикле уменьшать переменную заданное количество раз
short count = nr;
do 
:: (count >= 0) -> count--; 
:: else -> break;
od

//после ожидания проверить, нет ли блока и попытаться его сгенерировать
bool ifOurBlock = false;
if 
:: (state != STATE_MINEBLOCK) -> {
//еще нету, раз мы первые, то помечаем себя лидером
atomic {
state = STATE_MINEBLOCK; //мы поменяли, если другие не успели
procStates[N] = STATE_MINEBLOCK; //помечаем, что блок наш
ifOurBlock = true; 
}
if  //в других случаях  -  блок не наш
::(procStates[N] != STATE_MINEBLOCK) -> procStates[N] = STATE_NOMINEBLOCK; 
::else -> skip;
fi
}
:: else -> procStates[N] = STATE_NOMINEBLOCK;
fi
//далее логика по генерации блока, если условия выполнены
if 
:: ifOurBlock == true -> {
//мы думаем, что мы лидер - ждать все остальные процессы
do 
:: {
count = P - 1;
short countReady = 0; 
short countLeaders = 0; 
do
:: (count >= 0) -> {
if
//считаем количество процессов не лидеров
:: (procStates[count] == STATE_NOMINEBLOCK) || 
//а также новые процессы
(procStates[count] ==  STATE_INIT) -> {
countReady++; 
}
//считаем количество лидеров
:: (procStates[count] == STATE_MINEBLOCK) -> countLeaders++;
:: else ->  skip;
fi
count--;
}
:: else -> break;
od
if :: (countReady == P - 1) ->  //нормальное состояние - я лидер и других нет
{
isGenerating = true;
generator = N;
Nblock++;
printf("BLOCK %d generated by process %d! \n", Nblock, _pid);
isGenerating = false;
break;
}
:: (countLeaders != 1) -> { //что-то не так, несколько лидеров - перевыборы
printf("REELECTION! \n");
break;
}
:: else -> skip;
fi
} od
//инициировать новый раунд
state = STATE_INIT;
printf("NEW ROUND INITIATED BY %d \n", _pid);
}
::else -> 
skip;
fi
}
od
} 


active proctype main() {
state = STATE_WAITING;
short count = P - 1;
do
:: (count >= 0) -> {
procStates[count] = STATE_INIT;
run proc(count);
count--;
}
:: else -> break;
od
state = STATE_INIT;
}

\end{lstlisting}